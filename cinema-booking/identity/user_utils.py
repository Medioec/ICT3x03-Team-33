'''
    This file contains utility functions for the identity service.
    These include: checking availability of username and email, validating password, generating random number and generating uuid.
'''

import requests
import re
import secrets 
import uuid
from itsdangerous import URLSafeTimedSerializer
import string
import pyotp
import time

# check if username is available/does not exist in db
def isUsernameAvailable(username):
    data = {"username": username}
    response = requests.post("http://databaseservice:8085/databaseservice/user/check_user", json=data)

    # if username is not found in db, username is available
    if response.status_code == 404:
        return True 
    
     # username is taken
    elif response.status_code == 200:
        return False 
    
    else:
        raise Exception("Error occurred")

# check if email is available/does not exist in db
def isEmailAvailable(email):
    data = {"email": email}
    response = requests.post("http://databaseservice:8085/databaseservice/user/check_email", json=data)

    # if email is not found in db, email is available
    if response.status_code == 404:
        return True 
    
     # email is taken
    elif response.status_code == 200:
        return False 

    else:
        raise Exception("Error occurred")

# ensure that username is 3 - 16 characters, and only alphanumeric
def validateUsername(username):
    pattern = "^[a-zA-Z0-9]{3,16}$"
    if re.match(pattern, username):
        return True
    else:
        return False

# Load the wordlist into a set for efficient lookups
with open('/app/wordlist/blacklistedPW.txt', 'r', encoding='latin-1') as f:
    BLACKLISTED_PASSWORDS = set(line.strip() for line in f)

# ensure that password is valid
def validatePassword(password):
    # Check if password is in the blacklist
    if password in BLACKLISTED_PASSWORDS:
        return False

    # Regular expression pattern check
    # ensure that password is 12 - 32 characters 
    return (12 <= len(password) <= 32)

# generate uuid for inserting into db
def generateUUID():
    return str(uuid.uuid4())

# generate 32 bytes for a 256-bit key
def generateSecretKey():
    secret_key = secrets.token_bytes(32) 
    return secret_key

# generate a random 16 character string
def generateRandomString():
    return secrets.token_urlsafe(16)

# create unique email link using username, link type and set expiration time
def generateEmailLinks(serializer, username, link_type):
    email_link = serializer.dumps(username, salt=link_type)
    return email_link

 # seserialize the token to verify that its generated by us + within the validty window
def validateEmailLinks(serializer, token, link_type, expiration_time_in_seconds):
    try:
        username = serializer.loads(token, salt=link_type, max_age=expiration_time_in_seconds)
        return username

    except: 
        return None

def generateOTPWithTimestamp(len, expires_in_seconds):
    characters = string.ascii_uppercase + string.digits
    otp = ''.join(secrets.choice(characters) for _ in range(len))

    current_time = int(time.time())
    expiry_timestamp = current_time + expires_in_seconds

    return otp, expiry_timestamp

# verify that only alphanumeric characters are used
def validateOTP(otp):
    return otp.isalnum()

# def generateOTPWithTimestamp(totp, expires_in_seconds):
#     current_totp = totp.now()

#     current_time = int(time.time())
#     expiry_timestamp = current_time + expires_in_seconds

#     return current_totp, expiry_timestamp

# def generateOTP(totp):
#     current_totp = totp.now()
#     return current_totp

# def verifyOTP(totp, user_input):
#     return totp.verify(user_input)
